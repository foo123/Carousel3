<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>Carousel with HTML5 canvas and three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
				padding:0;
				position:relative;
				height:100%;
			}
		</style>
	</head>
	<body>

		<script src="Three.js"></script>
		<script type="text/javascript" src="Tween.js"></script>
		<script src="RequestAnimationFrame.js"></script>
		<script src="helvetiker_regular.typeface.js"></script>
		<script src="Carousel.js"></script>
		<div id="aside" style="position:absolute;color:#fff;font-size:12px;z-index:100;width:200px;">
		<ul>
		<li>Drag mouse left-right to rotate carousel</li>
		<li>Drag mouse up-down to zoom out/in</li>
		<li>Double Click on item to bring to front</li>
		</ul>
		</div>
		<div id="container" style="position:relative;margin:0 auto;padding:0;cursor:pointer"></div>
		<script>
			var container;

			var camera, scene, renderer, projector;
			var updatecamera=false,carouselupdate=true;

			var carousel;
			var images=[{url:'d1.jpg',width:150,height:100},{url:'d2.jpg',width:150,height:100},{url:'d3.jpg',width:150,height:100},{url:'d4.jpg',width:150,height:100},{url:'d5.jpg',width:150,height:100},{url:'d6.jpg',width:150,height:100}];
			var targetRotationY = 0;
			var targetRotationOnMouseDownY = 0;
			var targetRotationX = 0;
			var targetRotationOnMouseDownX = 0;

			var mouse={x:0,y:0},prevmouse={x:0,y:0};
			var mouseX = 0;
			var mouseXOnMouseDown = 0;
			var mouseY = 0;
			var mouseYOnMouseDown = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			
			init();
			animate();
			
			function rotateCarousel(item)
			{
				carouselupdate=false;
				var angle=(item.carouselAngle-Math.PI/2)%(2*Math.PI);
				var b=carousel.rotation.y%(2*Math.PI);
				var ang;
				if (b>0) b=-2*Math.PI+b;
				carousel.rotation.y=b;
				if (angle<b) angle+=2*Math.PI;
				if ((angle-b)>2*Math.PI-(angle-b))
				{
					ang=b+(-(2*Math.PI-(angle-b)));
				}
				else
				{
					ang=b+(angle-b);
				}
				new TWEEN.Tween(carousel.rotation).to({y:ang},800).easing(TWEEN.Easing.Exponential.EaseInOut).onComplete(function(){carouselupdate=true;targetRotationY=carousel.rotation.y;}).start();
			}
			
			function init() {
				container=document.getElementById('container');
				var w,h;
				w=window.innerWidth;
				h=window.innerHeight;
				container.style.width=w+"px";
				container.style.height=h+"px";
				container.style.marginTop=0.5*(window.innerHeight-h)+'px';
				
				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 70, w / h, 1, 1000 );
				camera.position.z = 500;
				scene.add( camera );

				// Carousel
				carousel=new Carousel(200,images,150,100);
				scene.add( carousel );
				
				projector = new THREE.Projector();
				
				renderer = new THREE.CanvasRenderer();
				renderer.setSize( w, h );

				container.appendChild( renderer.domElement );

				container.addEventListener( 'dblclick', onDblClick, false );
				container.addEventListener( 'mousedown', onDocumentMouseDown, false );
				container.addEventListener( 'touchstart', onDocumentTouchStart, false );
				container.addEventListener( 'touchmove', onDocumentTouchMove, false );
			}


			function onDblClick( event )
			{
				event.preventDefault();
				dblclick=true;
				
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( carousel.children );

				if ( intersects.length > 0 ) {
					rotateCarousel(intersects[0].object);
					}

			}
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				container.addEventListener( 'mousemove', onDocumentMouseMove, false );
				container.addEventListener( 'mouseup', onDocumentMouseUp, false );
				container.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				prevmouse={x:mouse.x,y:mouse.y};
				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationOnMouseDownY = targetRotationY;
				targetRotationOnMouseDownX = targetRotationX;
			}
			
			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				targetRotationY = targetRotationOnMouseDownY + ( mouseX - mouseXOnMouseDown ) * 0.02;
				targetRotationX = targetRotationOnMouseDownX + ( mouseY - mouseYOnMouseDown ) * 0.02;
				updatecamera=true;
			}

			function onDocumentMouseUp( event ) {

				container.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				container.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				container.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {

				container.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				container.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				container.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

				mouse.x = ( event.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
				prevmouse={x:mouse.x,y:mouse.y};
				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationOnMouseDownY = targetRotationY;
				targetRotationOnMouseDownX = targetRotationX;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

				mouse.x = ( event.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
				prevmouse={x:mouse.x,y:mouse.y};
				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationOnMouseDownY = targetRotationY;
				targetRotationOnMouseDownX = targetRotationX;
				updatecamera=true;
				}
			}

			//

			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				if (carouselupdate)
					carousel.rotation.y += ( targetRotationY - carousel.rotation.y ) * 0.05;
				if (updatecamera && Math.abs(mouse.y-prevmouse.y)>Math.abs(mouse.x-prevmouse.x))
					camera.position.z +=  (mouse.y-prevmouse.y)*20;
				renderer.render( scene, camera );
				updatecamera=false;
				//carouselupdate=true;
				TWEEN.update();
			}
		</script>
</body></html>